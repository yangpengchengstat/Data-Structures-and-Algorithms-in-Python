# Breadth-First Search (BFS)

Breadth-First Search (BFS) is a fundamental graph traversal algorithm used to explore vertices and edges of a graph. It's particularly important because it finds the shortest path between a starting vertex and all other reachable vertices in an **unweighted graph**.

The core idea of BFS is to explore the graph layer by layer, moving outward from a starting source vertex `s`.

## Core Concepts

### 1. Graphs

A graph `G = (V, E)` consists of a set of **vertices** `V` (nodes) and a set of **edges** `E` connecting pairs of vertices.

* **Undirected Graph**: Edges have no direction. If `u` is connected to `v`, then `v` is connected to `u`.
* **Directed Graph**: Edges have a direction. An edge `(u, v)` goes from `u` to `v` but not necessarily the other way.

### 2. Adjacency List

Graphs are commonly represented using an **adjacency list**. This is a mapping from each vertex `u` to a list of its neighbors, `Adj(u)`. For an unweighted graph, this representation is highly efficient, requiring `O(|V| + |E|)` space.

### 3. Level Sets

BFS works by identifying **level sets**. A level `L_i` is the set of all vertices that are at a shortest-path distance of exactly `i` from the source vertex `s`.

* `L_0` contains just the source vertex `s`.
* `L_1` contains all neighbors of `s`.
* `L_2` contains all unvisited neighbors of vertices in `L_1`.
* And so on...

This level-by-level exploration guarantees that when we first discover a vertex `v`, we have found a shortest path to it.

## The BFS Algorithm

The algorithm uses a queue to manage the "frontier" of vertices to visit next. It also uses a `parent` array (or dictionary) to keep track of how each vertex was discovered, which allows us to reconstruct the shortest paths.

**Steps:**

1.  **Initialization**:
    * Create a queue and add the source vertex `s` to it.
    * Create a `parent` array, initialized to `None`. Set `parent[s] = s` to mark it as the root and visited.
    * Create a `level` structure (e.g., a list of lists) to store the vertices in each level. Initialize `level[0]` with `s`.
2.  **Traversal**:
    * While the last level created is not empty:
        * Create a new, empty level.
        * For each vertex `u` in the current level:
            * For each neighbor `v` of `u`:
                * If `v` has not been visited (`parent[v]` is `None`):
                    * Mark `v` as visited by setting `parent[v] = u`.
                    * Add `v` to the new level.
3.  **Termination**: The algorithm ends when the frontier is empty, meaning all reachable vertices have been visited. The `parent` array now stores a **shortest-path tree**.

### Complexity Analysis

* **Time Complexity**: `O(|V| + |E|)`. Each vertex is enqueued and dequeued exactly once (`O(|V|)`). Every edge is examined exactly once (or twice in an undirected graph), leading to `O(|E|)`.
* **Space Complexity**: `O(|V|)`. In the worst case (a star graph), the queue can hold up to `|V| - 1` vertices. The `parent` array also requires `O(|V|)` space.

## Applications & Problems

### 1. Finding the Shortest Path

We can use the `parent` array generated by BFS to find the shortest path from the source `s` to any target `t`. We simply backtrack from `t` using the parent pointers until we reach `s`.

### 2. Odd-Length Shortest Path

**Problem**: Given an unweighted graph, find a shortest path from `s` to `t` that has an odd number of edges.

**Solution**: This classic problem can be solved by modifying the graph.

1.  **Construct a new graph `G'`**: For every vertex `u` in the original graph, create two new vertices in `G'`: `u_even` and `u_odd`. These represent reaching `u` via an even or odd number of edges, respectively.
2.  **Construct new edges**: For every edge `(u, v)` in the original graph, create two directed edges in `G'`: `(u_even, v_odd)` and `(u_odd, v_even)`.
3.  **Run BFS**: Run a standard BFS on `G'` starting from `s_even`. The shortest path from `s_even` to `t_odd` in `G'` corresponds to the shortest odd-length path from `s` to `t` in the original graph.
